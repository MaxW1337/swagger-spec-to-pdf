#!/usr/bin/env node
"use strict";

var ArgumentParser = require('argparse').ArgumentParser;
var cli = new ArgumentParser({
  prog:           "swagger2pdf",
  version:        require('../package.json').version,
  addHelp:        true
});
cli.addArgument(['-s', '--src'], {
  help:   'Swagger spec file.'
});
cli.addArgument(['-j', '--json'], {
  help:   'Spec file in JSON format (default).',
  nargs:  0,
});
cli.addArgument(['-y', '--yaml'], {
  nargs: 0,
  help:   'Spec file in YAML format.',
});
cli.addArgument(['-o', '--output'], {
  help:   'Output path of the pdf file.'
});

var path = require('path')
var fs = require('fs')
var cp = require('child_process')
var libYaml = require('yaml-js')
var express = require('express')
var app = express()
var path = require('path')

var rootPath = process.cwd();
var editorSpecPath = path.join(editorPath, '');
var httpServerPath = 'http-server';
var electronScript = path.join(__dirname, '..', 'src', 'electron_exec.js');
var electronPath = require('electron');

var parsePath = function(input) {
  if (input == '-') return '-';
  var output;
  if (!(input != null)) {
    return rootPath;
  }
  output = path.normalize(input);
  if (output.length === 0) {
    return rootPath;
  }
  if (output.charAt(0) !== '/') {
    output = path.normalize(rootPath + '/./' + output);
  }
  if (output.length > 1 && output.charAt(output.length - 1) === '/') {
    return output.substr(0, output.length - 1);
  }
  return output;
};

try {
  var options = cli.parseArgs();
  var src = parsePath(options.src);
  var output = parsePath(options.output);
  var inputJson = !options.yaml;

  // ensure only a single input format is selected, default to JSON otherwise
  if (options.yaml && options.json) {
    process.stderr.write("Both JSON and YAML selected, continuing as JSON");
    inputJson = true;
  }

  // ensure source file
  var srcStatus = fs.statSync(src);
  if (!srcStatus || !srcStatus.isFile()) {
    process.stderr.write('Source swagger spec not found: ' + src);
  }

  // ensure output dir
  var outputStatus = fs.statSync(output);
  if (!outputStatus || !outputStatus.isDirectory()) {
    process.stderr.write('Output dir not found: ' + output);
  }

  if (inputJson) {
    // read json spec & dump converted yaml into swagger editor spec dir
    var specJson = JSON.parse(fs.readFileSync(src));
    fs.writeFileSync(path.join(editorSpecPath, 'default.yaml'), libYaml.dump(specJson));
  } else {
    // if the source file is in YAML format already, simply copy it to the spec dir
    fs.copyFileSync(src, path.join(editorSpecPath, 'default.yaml'));
  }

  // start http server serving the editor site
app.get('/', function(req, res) {
    res.sendFile(editorPath + '/index.html');
});

app.listen(19849);
let httpServerSpawned = true

  // var httpServerSpawned = false;
  // var httpServerProcess = null;
  // var httpServerPathWatcher = setInterval(function() {
  //   if (!httpServerPath) {
  //     return;
  //   }
  //   clearInterval(httpServerPathWatcher);

  //   if (process.platform === 'win32') {
  //     httpServerProcess = cp.spawn(process.env.comspec, ['/c', httpServerPath, editorPath, '-p 19849', '-c -1']);
  //   } else {
  //     httpServerProcess = cp.spawn(httpServerPath, [editorPath, '-p 19849', '-c -1']);
  //   }
  //   httpServerProcess.stdout.on('data', function(data) {
  //     console.log(data.toString());
  //     httpServerSpawned = true;
  //   });
  // }, 100); // 0.1s

// wait for httpserver serving swagger-editor and start electron app when ready
  var watcher = setInterval(function() {
    if (!httpServerSpawned) {
      return;
    }
    clearInterval(watcher);

    var electronProcess = cp.spawn(electronPath, [electronScript, output]);
    electronProcess.stdout.on('data', function(data) {
      console.log(data.toString());
    });
    electronProcess.on('close', function(code) {
      httpServerProcess.kill();
      if (0 === code) {
        console.log('Done.');
      } else {
        process.stderr.write('Failed in executing electron script.');
      }
    });
  }, 100); // 0.1s

} catch (err) {
  process.stderr.write((err.message ? err.message : err) + "\n");
}
